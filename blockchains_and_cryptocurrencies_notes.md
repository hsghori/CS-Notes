---
title: "Blockchains and Cryptocurrencies Notees"
author: Haroon Ghori
geometry: margin=1in
---

# Background
- Math Concepts
    - Negligiable Functions: A function n(k) is negligible if for every polynomial p(k), there exists some k_0 such that for all k > k_0, n(k) < 1 / p(k). 
    - Group Theory
        - A group $G$ is a set of elements equipped with an operation ( * ) that combines any two elements to form a third element and that satisfies four conditions called the group axioms, namely closure, associativity, identity and invertibility.
            - Closure: given elements $a \ and \ b, a * b \in G$.
            - Associativity: for any $x, y, z \in G,\ (x * y) * z = x * (y * z)$.
            - Identity: there exists an $e \in G$ such that $e * x = x * e = x \forall x \in G$. We say that $e$ is an identity operator of $G$.
            - Invertibility: for any $x \in G \\exists y \in G \ s.t.\ x * y = e = y * x$. We say that $y$ is the inverse of $x$.  
        - A group $G$ is a cyclic group if it is generated by a single element. 
            - $G = \{g\}$
            - $G$ is order $n$ where $n = |G|$
    - Discrete Logarithm Problem: Let $G$ be a cyclic group of order $p$ with generator $g$ where $p$ is an n-bit prime number. Given $g$ and $g^a$ we cannot easily find $a$. 
- Cryptographic Hash Functions
    - A hash function H is a function that takes a string of arbitrary length as input and efficiently computes a fixed length string. 
    - Essentially a hash function compresses an arbitrary length string to a fixed length. 
    - A secure hash function must satisfy two major properties:
        - Collision Resistance
            - A hash function H is collision-resistant if for all uniform PPT adversaries A, there exists a negligible function n(k), where k denotes the security parameter, such that 
            $Pr(A(1^k) \to (x, x') \ s.t. \ x \neq x' \ and \ H(x) = H(x')) = n(k)$
            - Essentially collision resistance is the property where an adversary cannot easily find two unequal inputs with the same hash value. 
            - Based on this priciple we can assume that if $H(x) = H(y), x = y$. This becomes useful when recognizing messages since we can recognize duplicate messages by the hash. 
        - Pre-Image Resistance
            - A hash function H is preimage-resistant if for all PPT adversaries A, there exists a negligible function n(k), where k denotes the seurity parameter, uch that
            $Pr(x \in {0, 1}^{poly(k)}, A(1^k, H(x)) \to x' \ s.t. \ H(x') = H(x)) = n(k)$
            
            __Note__: that ${0, 1}^{poly(k)}$ is a uniform distribution of strings up through length $poly(k)$. 
            - Essentially preimage-resistance is the propertw where given $H(x)$, an adversary cannot easily find $x$. 
        - Collision resistance is said to be a stronger property than preimage resistance. If a Hash function is sufficiently compressing collision resistance implies preimage resistance. 
            - Proof:
            FSOC assume that a function $H$ is sufficiently compressing and collision resistant but not preimage resistant. Then there exists an adversary A such that: $A(X)$ returns some value x such that $H(x) = X$. Since $H$ is sufficiently compressing, running A(X) multiple times will result in different values of $x = {y, y', y'',...}$ all of which satisfy the property $H(x) = X$. Then $A$ is not collision resistant which contradicts our assumption. Therefore collision resistance implies preimage resistance. 
        - We can use a hash function to encode a message commitment scheme. A commitment scheme is a process by which we can "commit" a message and then others can verify whether messages are valid. 
            - General scheme
            ```Python
            (com, key) = commit(msg)
            isValid = verify(com, key, msg)
            ```
            - Hash scheme
            ```Python
            def commit(msg):
                key = random() 
                com = H(key) + msg 
                return (com, key)

            def verify(com, key, msg):
                return H(key | msg) == com

            (com, key) = commit(msg) 
            isValid = verify(com, key, msg) 
            ```
            - Weak Hiding: Given com, no PPT adversary can find msg. (preimage resistance)
            - Weak Binding: No PPT dversary can find $msg != msg'$ such that `verify(commit(msg), msg') == true`. (collision resistance)
            - SHA-256 Hash Function 
            ```
                        512 bit  512 bit
                        msg1     msg2
                         |        |
                         V        V
            256 bit --> [c] ---> [c] ---> ... ---> out
            ```
            - Suppose the message msg is of length L bits such that L is a multiple of 512 (if not we can pad with zeros). __Note__ that if c is a collision-resistant then SHA-256 is collision resistant.
    - Random Oracle
        - A random oracle is a function that always maps an input to the same random output.
        ```Python 
        def random_oracle(x):
            ''' 
             oracle is a pre-defined map object.
            '''
            if x in oracle:
                return oracle[x]
            y = random()
            oracle[x] = y 
            return x
        ```
        - By definition, the answers of a random oracle are unpredictable. 
        - Random oracles capture many secutiry properties such as preimage resistance and collision resistance. 
        - Hash functions are often masked as a random oracle. 
- Hash pointer
    - Pointer to where some info is stored that is a cryptographic hash of the info. 
       H(into) -> info
    - If we have a hash pointer we can ask to get the info back adn ask if the info has changed (by taking the hash of the retunred info). 
    - We can also use hash pointers to create a linked list: this is essentially a blockchain. 
```
                 block1
        H() -> | data1     |      block2
               | H(block2) | -> | data2     |      block3
                                | H(block3) | -> | data3     |
                                                 | H(block4) |-> ...
```                                              
    - This chain is tamper resistant. If any data is tampered with we can easily tell using the previous hash pointer (which propogates up to the root hash pointer). 
    - Merkle Tree: a binary tree with hash pointers.
        - We can prove membership in a Merkle tree in $O(logN)$. 
            - Example: See the tree below. To proove that data 
        - We can also create a sorted Merkle tree. 
            - Using a sorted Merkle tree we can verify non-membership in $O(logN)$
    - In generally we can use hash pointers in any pointer based data structure that has no cycles. 
```
                                       Merkel Root
                                    H0 = H(H1a | H1b)
                         /                                      \
                  H1a=H(H2a|H2b)                             H1b=H(H2c|H2d)
                    /         \                                /         \
        H2a=H(H_D1|H_D2)    H2b=H(H_D3, H_D4)       2a=H(H_D5|H_D6)    H2b=H(H_D7, H_D8)
            /    \                /   \                /    \                /   \           
          H_D1  H_D2            H_D3  H_D4           H_D5  H_D6            H_D7  H_D8
           D1    D2              D3   D4              D5    D6              D7   D8
```

- Digital Signitures
    - Only you can sign, but anyone can verify
    - Signiture is tied toa particular document
    - Even if one can see your signiture on some documents he cannot forge it. 
    - Scheme
    ```Python
        (sk, pk) = keygen(1^k) # sk = secret signing key, pk = public verification key
        sig = sign(sk, msg)
        isValid = verify(pk, message, sig)
    ```
    - Requirements for signiture Scheme
        - Must be correct
        - Unforgeability under chosen-message attacks (UF-CMAA). 
            - If an adversary who knows pk and gets to see signitures on messages of his choice, can't produce a verifiable signiture on another message. 
    - Note
        - Signitures can be shorter than the message: For example we can sign the hash(message)
        - Algorithms are randomized: they need good source of randomness - bad randomness may reveal the secret key. 
        - Sign a hash pointer - then the signiture covers the whole structure. 
        - Bitcoin uses Eliptic Curve Digital Signiture Algorithm (ECDSA)
        - ECDSSA is a close variant of Schnorr Signature scheme over Eliptic curves. 
    - Schnorr Signiture Scheme
        - Let $g$ be a generator for a cyclic group $G$ of order $p$. (See definition of group and cyclic group above). 
        ```Python
        def keygen(s):
            sk = random(Z_p) # Z_p is the set of all integers of length p
            pk = g^sk
            return (sk, pk)

        def sign(sk, msg):
            t = random(Z_p)
            r = g^t 
            h = H(msg, r)
            s = t + (h * sk)
            return (h, s)

        def verify(pk, msg, sigma):
            (h, s) = sigma
            return H(msg, g^s / pk^h) == h

        (sk, pk) = keygen(1^k)
        sigma = sign(sk, msg)
        isValid = verify(pk, msg, sigma)
        ```
        - Verify, If we're given a correct message, public key, and signiture then:
        $$\frac{g^s}{pk^h}$$
        $$s = t + h * sk$$
        $$g^s = g^t * (g^sk)^h = g^t * pk^h$$
        $$\frac{g^s}{pk^h} = \frac{g^t * pk^h}{pk^h} = g^t$$
        $$H(msg, r) = h $$
        Verify returns 1.  
        - Assuming the hardness of the discrete logarithm problem, Schorr signiture scheme is UF-CMA is secure in the random oracle model. 
            Proof: 
            __FILL IN__
            https://crypto.stackexchange.com/questions/48616/prove-the-security-of-schnorrs-signature-scheme

# Basics of Cyptocurrencies
- When we see a `pk` and `sigma` such that `verify(pk, msg, sigma) = True` we can think of `pk` as saying the message. However, in order to speak for `pk` you must know `sk` (because the message must be signed with the secret key). 
- An identity (or address in bitcoin) is essentially a public / secret key pair. 
- Decentralized identity management means that anyone can make an identity at any time - there is no central point of coordination. 
- Addresses are not directly connected to people's real-world identity.
    - But an ovserver can link an adresses's activity over time and make inferences about the identity associated with an address. So, this scheme doesn't garuntee anonymity. 
- GoofyCoin
    - One central authority (called Goofy). Goofy is the only entity that can create new coins. Any coins created by Goofy belong to goofy. 
    ```Python
        coin = createCoin(uniqueID) # creates a unique 
        sigma = sign(coin, pk_goofy)
    ```
    - This essentially constitutes a block 
    ```
        | signed by pk_goofy   |
        | createCoin(uniqueID) |
    ```
    - If goofy wants to pay Alice a coin, he can use a hash pointer to point to the original block, pass hat to alice and sign with Alic's public key. 
    ```
        | signed by pk_alice  |
        | H()                 | -> | signed by pk_goofy   |
                                   | createCoin(uniqueID) |
    ```
    - If Alice now wants to pay Bob she can use the same procedure.
    ```
    | signed by pk_bob   |    
    | H()                | -> | signed by pk_alics  |
                              | H()                 | -> | signed by pk_goofy   |
                                                         | createCoin(uniqueID) |
    ```
    - The problem with this approach is that Alice doesn't have to tell anyone eshe's paying a coin. So she can easily pay a coin to bob, keep a copy of hte coin, and then pay it to Chuck. This is called a __double spending attack__ and is one of the major design challenges of cryptocurrencies. 
    ```
    | signed by pk_bob   |    
    | H()                | -> | signed by pk_alics  |
                              | H()                 | -> | signed by pk_goofy   |
    | signed by pk_chuck | -> |                     |    | createCoin(uniqueID) |
    | H()                |                               
    ```                                                         
- ScrougeCoin
    - One central authority (called Scrouge). Scrouge maintains a ledger of transactions and must sign off on any transaction. 
    - Every transaction is appended to the blockchain and signed off by Scrouge. The entire ledger is public and the final hash pointer is signed by Scrouge - the blockchain is only considered valid if it's signed by Scrouge. If an attacker were to modify an individual block (for example to give hiimself more money) the change would propogate up the blockchain - then `verify(H(), pk_scrouge)` would fail and the attack would be foiled. 
    ```      
     sig by scruge , H() ->  | transN    |      
                             | H()       | -> | transN-1  |      
                                              | H()       | -> | transN-2  |
                                                               | H()       |-> ...
    ```
    - An invalid transaction (ie a double spending attack) must be verified by Scrouge before being added to the blockchain. 
    - In this system Coins cannot be transfered - rather if Alice wants to pay N coins to Bob, she must:
        1. Give N coins to Scrouge
        2. Scouge verifies transaction.
        ```
            1. Consumed coins are valid 
            2. Consumed coins are in cicrulation (not previously consumed)
            3. Total value to be consumed == total value to issue 
            4. Signed by owners of all consumed coins
        ```
        2. Coins are consumed by Scrouged
        3. Scrouge issues N new coins to Bob.
    - This is reliant on Scrouge being a trusted authority. 

# Bitcoin 
- Bitcoin uses a ledger based system similar to ScrougeCoin. The innovation in bitcoin is the aspects of decentralization while preventing double spending. 
    - Bitcoin is meant to be a peer to peer network. All nodes should have a direct path to all other nodes. 
    - Mining new blocks is open to anyone, but eventually power is concentrated.  
    - Core developers trusted in the community have a lot of power when it comes to updating the system. 
- Distributed Consensus - maintaining the correct / same version of a database over a distributed system. 
    - Eventually the protocol terminates and all honest nodes decide on the same value. 
    - This output value must have been proposed by some honest node. 
- Transactions
    - When Alice wants to pay Bob she broadcasts the transaction to all Bitcoin nodes. 
    - A node has a blockchain which it assumes are valid and a set of transactions it's heard about. 
- Distributed Consensus in Bitcoin
    - At any given time:
        - all nodes have a sequence of blocks of transactions on which they've reached consensus. 
        - Each node has a set of outstanding transactions it's "heard about"
    - Innovations in bitcoin 
        - Introduces incentives
        - Enbraces randomness
            - Does away with the notion of a specific end-point 
            - Consensus happens over long time scales (1 hr)
    - Idea 
        - Lottery or raffle 
        - In ach round a random node is picked. 
        - That node proposes the next block in the chain. 
        - Other nodes accept or reject this block 
            - Verify transactions on the block
            - Accept -> nodes add this block to their blockchain
                - Includes the block's hash in the next block it creates
            - Reject -> ignoring the proposed block and extending chain from earlier block 
        - Confirmation of a transaction can onnly happen after a few block have been mined. 
            - Nodes extend their chain by following the longest current chain. 
            - There must be 6 confirmations (block must be extended 6 times) before it is accepted in teh blockchain. 
            - Double spending probability decreases exponentialy with number of confirmations. 
```
                                | H()   | \  
                                | data  |   -> | H()  | -> | H()  | -> | H()  |
                                            -> | data |    | data |    | data |
                                | H()   | / 
                                | data* | 

    data* contains some kind of double spending attack or invalid transaction
```
    - Incentive
        - Block Reward  
            - Block creator (node that broadcasts a proposed block on a round) includes a special coin creation transaction in the block which pays the creator for creating the blcok. 
            - Block creator gets to collect the reward only if the block ends up on the long term consensus branch. 
        - Transaction fee 
            - <FILL IN> 
    - Proof of Work 
        - Select node in proportion to computing power. 
            - $P(node_A) = \frac{power_A}{total \ power}$
        - Let nodes compete for right to create block 
        - Make it moderately hard to create new identities. 
            - Defeat Sybil attacks (creating a bunch of identities to increase presene in the network). 
        - To create a block find $nonce$ such that:
        $$H(nonce | block) < D$$ 
        where d is small and the block contains the previous hash and all transactions in the block. 
        (the exaact implimentation is that the first n bits of $D$ are $0$). 
            - This problem can only really be solved by guess and check. 
            - As of 8/2014 a computer needed to compute $10^20$ hashes / bblock. 
                - Only some nodes have the hardware to compete and decide to be miners. 
        - Nodes automatically recalculate the target ($D$) every two weeks. THe goal is that the average time between blocks being mined is 10mins. 
        - The $nonce$ should be published as part of the block that is mined. That way other miners can simply verify the solution by running $H(nonce | block) < D$. 


